using ModCreator.Attributes;
using ModCreator.Helpers;
using ModCreator.Models;
using Newtonsoft.Json;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Xml.Linq;

namespace ModCreator.WindowData
{
    public class PatternSelectorWindowData : CWindowData
    {
        private List<RegularPattern> _allPatterns;
        private Dictionary<string, ModConfElement> _allElements;
        private Dictionary<string, List<ModConfValue>> _allValues;
        private string _projectPath;

        [NotifyMethod(nameof(FilterPatterns))]
        public string SearchText { get; set; }

        [NotifyMethod(nameof(LoadExistingFiles))]
        public string Prefix { get; set; }

        public ObservableCollection<RegularPattern> FilteredPatterns { get; set; }

        private RegularPattern _selectedPattern;
        public RegularPattern SelectedPattern
        {
            get => _selectedPattern;
            set
            {
                _selectedPattern = value;
                UpdateDisplayFiles();
            }
        }

        public ObservableCollection<PatternFileDisplay> DisplayFiles { get; set; }

        public bool HasSelectedPattern => SelectedPattern != null;

        public bool HasExistingFiles
        {
            get
            {
                if (string.IsNullOrEmpty(_projectPath) || SelectedPattern == null)
                    return false;

                var confPath = System.IO.Path.Combine(_projectPath, "ModProject", "ModConf");
                if (!System.IO.Directory.Exists(confPath))
                    return false;

                foreach (var file in SelectedPattern.Files)
                {
                    var fileName = GetPrefixedFileName(file.FileName);
                    var filePath = System.IO.Path.Combine(confPath, fileName);

                    if (System.IO.File.Exists(filePath))
                        return true;
                }

                return false;
            }
        }

        public PatternSelectorWindowData()
        {
            _allPatterns = new List<RegularPattern>();
            _allElements = new Dictionary<string, ModConfElement>();
            _allValues = new Dictionary<string, List<ModConfValue>>();
            FilteredPatterns = new ObservableCollection<RegularPattern>();
            DisplayFiles = new ObservableCollection<PatternFileDisplay>();
            LoadPatterns();
        }

        private string GetPrefixedFileName(string fileName)
        {
            if (string.IsNullOrEmpty(Prefix))
                return fileName;

            var fileNameWithoutExt = System.IO.Path.GetFileNameWithoutExtension(fileName);
            var ext = System.IO.Path.GetExtension(fileName);
            return $"{Prefix}_{fileNameWithoutExt}{ext}";
        }

        private void UpdateDisplayFiles()
        {
            DisplayFiles.Clear();
            if (SelectedPattern == null)
                return;

            foreach (var file in SelectedPattern.Files)
            {
                var displayFile = new PatternFileDisplay { FileName = file.FileName };

                foreach (var elementName in file.Elements)
                {
                    var element = ResolveElement(elementName);
                    if (element != null && element.Enable)
                    {
                        displayFile.Elements.Add(element);

                        if (element.Type == "composite" && element.SubElements != null && element.SubElements.Count > 0)
                        {
                            foreach (var subElement in element.SubElements)
                            {
                                if (subElement.Enable)
                                {
                                    displayFile.Elements.Add(subElement);
                                    displayFile.DisplayElements.Add(subElement);
                                }
                            }
                        }
                        else
                        {
                            if (element.IsAutoGenerated)
                                element.IsReadOnly = true;

                            displayFile.DisplayElements.Add(element);
                        }
                    }
                }

                displayFile.AddRow();
                DisplayFiles.Add(displayFile);
            }

            LoadExistingFiles(this, null, null, null);
            foreach (var displayFile in DisplayFiles)
            {
                foreach (var element in displayFile.Elements)
                {
                    LoadDynamicOptionsForElement(element);
                }
            }
        }

        public void SetProjectPath(string projectPath)
        {
            _projectPath = projectPath;
            Notify(this, nameof(HasExistingFiles));
        }

        public void LoadExistingFiles(object obj, System.Reflection.PropertyInfo prop, object oldValue, object newValue)
        {
            if (string.IsNullOrEmpty(_projectPath) || SelectedPattern == null)
            {
                Notify(this, nameof(HasExistingFiles));
                return;
            }

            var confPath = System.IO.Path.Combine(_projectPath, "ModProject", "ModConf");
            if (!System.IO.Directory.Exists(confPath))
                return;

            foreach (var file in DisplayFiles)
            {
                var fileName = GetPrefixedFileName(file.FileName);
                var filePath = System.IO.Path.Combine(confPath, fileName);

                if (!System.IO.File.Exists(filePath))
                    continue;

                var jsonContent = Helpers.FileHelper.ReadTextFile(filePath);
                if (string.IsNullOrEmpty(jsonContent))
                    continue;

                var jsonArray = JsonConvert.DeserializeObject<List<Dictionary<string, object>>>(jsonContent);
                if (jsonArray != null && jsonArray.Count > 0)
                {
                    file.Rows.Clear();
                    foreach (var jsonObject in jsonArray)
                    {
                        var row = new Dictionary<string, string>();
                        foreach (var element in file.Elements)
                        {
                            if (element.Type == "composite")
                            {
                                if (jsonObject.ContainsKey(element.Name))
                                {
                                    var compositeValue = jsonObject[element.Name]?.ToString() ?? string.Empty;
                                    PatternHelper.DecomposeCompositeValue(element, compositeValue, row);
                                }
                            }
                            else if (jsonObject.ContainsKey(element.Name))
                            {
                                row[element.Name] = jsonObject[element.Name]?.ToString() ?? string.Empty;
                            }
                            else if (element.IsAutoGenerated)
                            {
                                row[element.Name] = PatternHelper.ProcessAutoGenValue(element.ElementFormat, row);
                            }
                            else if (!element.IsSubElement)
                            {
                                row[element.Name] = element.Value ?? string.Empty;
                            }
                        }
                            
                        file.Rows.Add(new RowDisplay(row, file.Elements, file.DisplayElements));
                    }
                }
            }

            Notify(this, nameof(HasExistingFiles));
        }

        public void LoadPatterns()
        {
            _allPatterns.Clear();
            _allElements.Clear();
            _allValues.Clear();

            _allPatterns = ResourceHelper.ReadEmbeddedResource<List<RegularPattern>>("ModCreator.Resources.modconf-patterns.json");
            FilterPatterns(this, null, null, null);

            var elements = ResourceHelper.ReadEmbeddedResource<List<ModConfElement>>("ModCreator.Resources.modconfs.json");
            foreach (var element in elements)
                _allElements[element.Name] = element;

            var valueGroups = ResourceHelper.ReadEmbeddedResource<List<ModConfValueGroup>>("ModCreator.Resources.modconf-values.json");
            foreach (var group in valueGroups)
                _allValues[group.Name] = group.Values;
        }

        public PatternElement ResolveElement(string elementName)
        {
            var actualElementName = elementName;
            string pattern = null;

            if (elementName.Contains(":"))
            {
                var parts = elementName.Split(':');
                actualElementName = parts[0];
                pattern = parts[1];
            }

            if (!_allElements.TryGetValue(actualElementName, out var element))
                return null;

            var patternElement = new PatternElement
            {
                Name = PatternHelper.GetKeyAfterFirstDot(actualElementName),
                Type = element.Type,
                Label = element.Label,
                Description = element.Description,
                VarType = element.VarType,
                Enable = element.Enable,
                Required = element.Required,
                Value = element.Value,
                Separator = element.Separator
            };

            if (pattern != null && pattern.StartsWith("[") && pattern.EndsWith("]"))
            {
                patternElement.Type = "combo";
                patternElement.ElementFormat = pattern;
            }
            else if (pattern != null)
            {
                patternElement.ElementFormat = pattern;
            }
            
            if (element.Options != null)
            {
                foreach (var optionRef in element.Options)
                {
                    if (_allValues.TryGetValue(optionRef, out var values))
                    {
                        foreach (var v in values)
                            patternElement.Options.Add(v);
                    }
                }
            }

            if (element.Type == "composite" && element.SubProperties != null)
            {
                foreach (var subPropName in element.SubProperties)
                {
                    var subElement = ResolveElement(subPropName);
                    if (subElement != null)
                    {
                        subElement.ParentElement = patternElement;
                        subElement.Required = patternElement.Required;
                        patternElement.Required = false;
                        patternElement.SubElements.Add(subElement);
                    }
                }
            }

            return patternElement;
        }

        public void LoadDynamicOptionsForElement(PatternElement element)
        {
            if (!element.IsDynamicOptions)
                return;

            var sourceKey = element.ElementFormat.Substring(1, element.ElementFormat.Length - 2);
            var actualSourceKey = PatternHelper.GetKeyAfterFirstDot(sourceKey);
            var valueSet = new HashSet<string>();

            foreach (var displayFile in DisplayFiles)
            {
                var sourceElement = displayFile.Elements.FirstOrDefault(e => e.Name == actualSourceKey);
                if (sourceElement == null)
                    continue;

                foreach (var row in displayFile.Rows)
                {
                    if (row.RowData.TryGetValue(actualSourceKey, out var value) && !string.IsNullOrEmpty(value))
                    {
                        valueSet.Add(value);
                    }
                }
            }

            element.Options.Clear();
            foreach (var value in valueSet)
            {
                element.Options.Add(new ModConfValue
                {
                    DisplayName = value,
                    Value = value
                });
            }
            element.Notify(element, nameof(element.Options));
        }

        public void FilterPatterns(object obj, System.Reflection.PropertyInfo prop, object oldValue, object newValue)
        {
            FilteredPatterns.Clear();
            var filtered = string.IsNullOrWhiteSpace(SearchText)
                ? _allPatterns
                : _allPatterns.Where(p => p.Name.Contains(SearchText, System.StringComparison.OrdinalIgnoreCase) 
                    || p.Description.Contains(SearchText, System.StringComparison.OrdinalIgnoreCase));

            foreach (var pattern in filtered.OrderBy(p => p.Name))
                FilteredPatterns.Add(pattern);
        }
    }
}
